import sys
import time
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTextEdit, QLineEdit, QPushButton, QComboBox, QTableWidget,
    QTableWidgetItem, QSplitter, QStatusBar, QLabel, QHeaderView
)
from PyQt5.QtCore import Qt, QCoreApplication, pyqtSignal

# Mocking LangChain components for demonstration purposes
# In a real application, you would import these from langchain
class ChatMessageHistory:
    def __init__(self):
        self.messages = []

    def add_user_message(self, message):
        self.messages.append({"role": "user", "content": message})

    def add_ai_message(self, message):
        self.messages.append({"role": "ai", "content": message})

    def get_messages(self):
        return self.messages

class ChatOpenAI:
    def __init__(self, api_key, temperature):
        self.api_key = api_key
        self.temperature = temperature

    def invoke(self, input_data):
        # Simulate LLM response
        user_input = input_data.get("input", "")
        if not self.api_key:
            raise ValueError("API Key is not set.")
        if not user_input:
            raise ValueError("Input message is empty.")
        
        # Simple mock response
        response_content = f"Mock AI response to '{user_input}' with temp {self.temperature}."
        return type('Response', (object,), {'content': response_content})()

class ChatPromptTemplate:
    @staticmethod
    def from_messages(messages):
        # Simulate prompt template
        return type('Prompt', (object,), {'messages': messages})()

class RunnableWithMessageHistory:
    def __init__(self, chain, get_session_history, input_messages_key, history_messages_key):
        self.chain = chain
        self.get_session_history = get_session_history
        self.input_messages_key = input_messages_key
        self.history_messages_key = history_messages_key

    def invoke(self, input_data, config):
        session_id = config.get("configurable", {}).get("session_id")
        chat_history = self.get_session_history(session_id)
        
        # Add user message to history
        user_message = input_data.get(self.input_messages_key, "")
        chat_history.add_user_message(user_message)

        # Simulate LLM response using the chain
        try:
            response = self.chain.invoke(input_data)
            ai_message_content = response.content
            chat_history.add_ai_message(ai_message_content)
            return response
        except Exception as e:
            raise e


# Custom QTextEdit to emit signal when focus leaves
class CustomTextEdit(QTextEdit):
    call_OutFocus = pyqtSignal()

    def focusOutEvent(self, event):
        super().focusOutEvent(event)
        self.call_OutFocus.emit()
        
class userTextEdit(QTextEdit):
    call_OutFocus = pyqtSignal()

    def focusOutEvent(self, event):
        super().focusOutEvent(event)
        self.call_OutFocus.emit()

# --- UI_MainWindow Placeholder ---
# This class simulates the UI generated by Qt Designer.
# In a real project, this would be in a separate file (e.g., ui_mainwindow.py)
class Ui_MainWindow:
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1000, 700)
        
        self.centralwidget = QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        
        self.main_layout = QHBoxLayout(self.centralwidget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)

        # Left Panel: Chat Room Manager
        self.left_panel_widget = QWidget()
        self.left_panel_layout = QVBoxLayout(self.left_panel_widget)
        self.left_panel_layout.setContentsMargins(0, 0, 0, 0)
        self.left_panel_layout.setSpacing(5)

        self.chat_manager_table = QTableWidget()
        self.chat_manager_table.setColumnCount(1)
        self.chat_manager_table.setHorizontalHeaderLabels(["Chat Rooms"])
        self.chat_manager_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.chat_manager_table.verticalHeader().setVisible(False)
        self.chat_manager_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.chat_manager_table.setSelectionMode(QTableWidget.SingleSelection)

        self.new_chat_btn = QPushButton("New Chat")
        self.delete_chat_btn = QPushButton("Delete Chat")
        
        self.button_layout = QHBoxLayout()
        self.button_layout.addWidget(self.new_chat_btn)
        self.button_layout.addWidget(self.delete_chat_btn)

        self.left_panel_layout.addWidget(QLabel("Chat Rooms:"))
        self.left_panel_layout.addWidget(self.chat_manager_table)
        self.left_panel_layout.addLayout(self.button_layout)

        # Right Panel: Chat Interface
        self.right_panel_widget = QWidget()
        self.right_panel_layout = QVBoxLayout(self.right_panel_widget)
        self.right_panel_layout.setContentsMargins(0, 0, 0, 0)
        self.right_panel_layout.setSpacing(5)

        # API Key, Prompt, Temperature settings
        self.settings_layout = QVBoxLayout()
        self.settings_layout.setSpacing(5)

        self.api_key_layout = QHBoxLayout()
        self.api_key_layout.addWidget(QLabel("API Key:"))
        self.api_key_txt = QLineEdit()
        self.api_key_txt.setPlaceholderText("Enter your API Key")
        self.api_key_layout.addWidget(self.api_key_txt)
        self.settings_layout.addLayout(self.api_key_layout)

        self.prompt_layout = QVBoxLayout()
        self.prompt_layout.addWidget(QLabel("System Prompt:"))
        self.prompt_txt = CustomTextEdit() # Use custom text edit for focus out signal
        self.prompt_txt.setPlaceholderText("Enter system prompt (e.g., You are a helpful AI assistant.)")
        self.prompt_txt.setFixedHeight(80)
        self.settings_layout.addLayout(self.prompt_layout)
        self.prompt_layout.addWidget(self.prompt_txt)

        self.temp_layout = QHBoxLayout()
        self.temp_layout.addWidget(QLabel("Temperature:"))
        self.temp_combo = QComboBox()
        self.temp_combo.addItems(["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"])
        self.temp_combo.setCurrentText("0.7")
        self.temp_layout.addWidget(self.temp_combo)
        self.settings_layout.addLayout(self.temp_layout)

        self.right_panel_layout.addLayout(self.settings_layout)
        self.right_panel_layout.addSpacing(10)

        # Chat History Displays
        self.chat_displays_layout = QHBoxLayout()
        self.chat_displays_layout.setSpacing(10)

        self.non_history_group = QVBoxLayout()
        self.non_history_group.addWidget(QLabel("Default LLM Output (No History):"))
        self.non_history_txt = QTextEdit()
        self.non_history_txt.setReadOnly(True)
        self.non_history_group.addWidget(self.non_history_txt)
        self.chat_displays_layout.addLayout(self.non_history_group)

        self.history_group = QVBoxLayout()
        self.history_group.addWidget(QLabel("History LLM Output:"))
        self.history_txt = QTextEdit()
        self.history_txt.setReadOnly(True)
        self.history_group.addWidget(self.history_txt)
        self.chat_displays_layout.addLayout(self.history_group)

        self.right_panel_layout.addLayout(self.chat_displays_layout)
        self.right_panel_layout.addSpacing(10)

        # Input and Send Button
        self.input_layout = QHBoxLayout()
        # self.input_text = QTextEdit()
        self.input_text = userTextEdit()
        self.input_text.setPlaceholderText("Enter your message...")
        self.input_text.setFixedHeight(60)
        self.send_btn = QPushButton("Send")
        self.send_btn.setFixedSize(80, 60)
        
        self.input_layout.addWidget(self.input_text)
        self.input_layout.addWidget(self.send_btn)
        self.right_panel_layout.addLayout(self.input_layout)

        # Splitter to resize panels
        self.splitter = QSplitter(Qt.Horizontal)
        self.splitter.addWidget(self.left_panel_widget)
        self.splitter.addWidget(self.right_panel_widget)
        self.splitter.setSizes([250, 750]) # Initial sizes

        self.main_layout.addWidget(self.splitter)
        MainWindow.setCentralWidget(self.centralwidget)
        
        self.statusbar = QStatusBar(MainWindow)
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QCoreApplication.processEvents() # Ensure UI updates

    def retranslateUi(self, MainWindow):
        _translate = QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Chat Manager"))
        self.new_chat_btn.setText(_translate("MainWindow", "New Chat"))
        self.delete_chat_btn.setText(_translate("MainWindow", "Delete Chat"))
        self.send_btn.setText(_translate("MainWindow", "Send"))


# --- ChatRoom Class ---
class ChatRoom:
    def __init__(self, name="New Chat"):
        self.name = name
        self.api_key = None
        self.temperature = "0.7"  # Default temperature
        self.prompt = "You are a helpful AI assistant." # Default prompt
        self.chat_history = ChatMessageHistory()
        self.non_history_log = "" # Store raw log for non-history
        self.history_log = ""     # Store raw log for history
        self.input_txt = ""

    def append_non_history_log(self, text):
        self.non_history_log += text + "\n"

    def append_history_log(self, text):
        self.history_log += text + "\n"


# --- Window Class ---
class Window(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        self.chat_rooms = []
        self.current_chat_room = None
        self.session_id_counter = 0 # For RunnableWithMessageHistory session_id

        self.connectSignalsSlots()
        self.add_new_chat_room(initial=True) # Add an initial chat room

    def connectSignalsSlots(self):
        self.ui.send_btn.clicked.connect(self.load_message)
        self.ui.api_key_txt.editingFinished.connect(self.apply_api_key)
        self.ui.prompt_txt.call_OutFocus.connect(self.apply_prompt)
        self.ui.temp_combo.currentTextChanged.connect(self.apply_temperature)
        self.ui.input_text.call_OutFocus.connect(self.store_user_input)
        
        self.ui.new_chat_btn.clicked.connect(self.add_new_chat_room)
        self.ui.delete_chat_btn.clicked.connect(self.delete_selected_chat_room)
        self.ui.chat_manager_table.itemSelectionChanged.connect(self.load_selected_chat_room)
        
        # Ensure the prompt text is applied when the app starts if there's default text
        # self.apply_prompt() 

    def show_status_message(self, message, is_error=False):
        if is_error:
            self.ui.statusbar.setStyleSheet("QStatusBar {background-color: #ffcccc; color: red;}")
        else:
            self.ui.statusbar.setStyleSheet("QStatusBar {background-color: #ccffcc; color: green;}")
        self.ui.statusbar.showMessage(message, 3000) # Show for 3 seconds

    def update_chat_room_list(self):
        self.ui.chat_manager_table.setRowCount(len(self.chat_rooms))
        for i, room in enumerate(self.chat_rooms):
            item = QTableWidgetItem(room.name)
            item.setData(Qt.UserRole, room) # Store the ChatRoom object in the item
            self.ui.chat_manager_table.setItem(i, 0, item)
        
        # Select the current chat room in the list
        if self.current_chat_room and self.current_chat_room in self.chat_rooms:
            index = self.chat_rooms.index(self.current_chat_room)
            self.ui.chat_manager_table.selectRow(index)
        elif self.chat_rooms:
            self.ui.chat_manager_table.selectRow(0) # Select first if no current or current deleted

    def add_new_chat_room(self, initial=False):
        new_room_name = f"Chat {len(self.chat_rooms) + 1}"
        new_room = ChatRoom(name=new_room_name)
        self.chat_rooms.append(new_room)
        self.update_chat_room_list()
        
        if not initial:
            self.current_chat_room = new_room
            self.load_chat_room_data_into_ui(new_room)
            self.show_status_message(f"New chat room '{new_room_name}' created.")
            self.ui.chat_manager_table.selectRow(len(self.chat_rooms) - 1) # Select the newly added row

    def delete_selected_chat_room(self):
        selected_rows = self.ui.chat_manager_table.selectedIndexes()
        if not selected_rows:
            self.show_status_message("No chat room selected to delete.", is_error=True)
            return

        row_to_delete = selected_rows[0].row()
        room_to_delete = self.chat_rooms[row_to_delete]

        if len(self.chat_rooms) == 1:
            self.show_status_message("Cannot delete the last chat room. Create a new one first.", is_error=True)
            return

        self.chat_rooms.pop(row_to_delete)
        self.show_status_message(f"Chat room '{room_to_delete.name}' deleted.")
        self.update_chat_room_list()

        # If the deleted room was the current one, select a new current room
        if room_to_delete == self.current_chat_room:
            if self.chat_rooms:
                # Try to select the row before the deleted one, or the first one
                new_selection_index = min(row_to_delete, len(self.chat_rooms) - 1)
                self.ui.chat_manager_table.selectRow(new_selection_index)
                self.current_chat_room = self.chat_rooms[new_selection_index]
                self.load_chat_room_data_into_ui(self.current_chat_room)
            else:
                self.current_chat_room = None
                self.clear_chat_ui() # Clear UI if no rooms left (shouldn't happen with the check above)


    def load_selected_chat_room(self):
        selected_items = self.ui.chat_manager_table.selectedItems()
        if selected_items:
            selected_row = selected_items[0].row()
            room = self.chat_rooms[selected_row]
            if room != self.current_chat_room: # Only update if a different room is selected
                self.current_chat_room = room
                self.load_chat_room_data_into_ui(room)
                self.show_status_message(f"Switched to chat room: '{room.name}'")
        else:
            # If nothing is selected (e.g., after deletion of last item), clear UI
            self.current_chat_room = None
            self.clear_chat_ui()

    def load_chat_room_data_into_ui(self, room):
        # Disconnect signals temporarily to prevent unwanted triggers
        self.ui.api_key_txt.editingFinished.disconnect(self.apply_api_key)
        self.ui.prompt_txt.call_OutFocus.disconnect(self.apply_prompt)
        self.ui.temp_combo.currentTextChanged.disconnect(self.apply_temperature)

        self.ui.api_key_txt.setText(room.api_key if room.api_key else "")
        self.ui.prompt_txt.setText(room.prompt if room.prompt else "")
        self.ui.temp_combo.setCurrentText(room.temperature)
        self.ui.non_history_txt.setText(room.non_history_log)
        self.ui.history_txt.setText(room.history_log)
        self.ui.input_text.setText(room.input_txt)

        # Reconnect signals
        self.ui.api_key_txt.editingFinished.connect(self.apply_api_key)
        self.ui.prompt_txt.call_OutFocus.connect(self.apply_prompt)
        self.ui.temp_combo.currentTextChanged.connect(self.apply_temperature)

    def clear_chat_ui(self):
        self.ui.api_key_txt.clear()
        self.ui.prompt_txt.clear()
        self.ui.temp_combo.setCurrentText("0.7") # Reset to default
        self.ui.non_history_txt.clear()
        self.ui.history_txt.clear()
        self.ui.input_text.clear()

    def load_message(self):
        if not self.current_chat_room:
            self.show_status_message("Please select or create a chat room first.", is_error=True)
            return

        message = self.ui.input_text.toPlainText()

        if message.strip():
            self.ui.input_text.clear()
            self.current_chat_room.append_non_history_log(f"Sended Message: {message}")
            self.current_chat_room.append_non_history_log("")
            self.current_chat_room.append_history_log(f"Sended Message: {message}")
            self.current_chat_room.append_history_log("")
            
            self.default_llm(message)
            self.history_llm(message)
        else:
            self.show_status_message("Please enter any message.", is_error=True)

    def apply_api_key(self):
        if not self.current_chat_room: return
        
        api_key = self.ui.api_key_txt.text().strip()
        if api_key:
            self.current_chat_room.api_key = api_key
            self.show_status_message("API Key applied successfully.")
        else:
            self.current_chat_room.api_key = None # Clear if empty
            self.show_status_message("API Key cleared.", is_error=True)

    def apply_prompt(self):
        if not self.current_chat_room: return

        prompt = self.ui.prompt_txt.toPlainText().strip()
        if self.current_chat_room.prompt == prompt:
            return
        elif prompt:
            self.current_chat_room.prompt = prompt
            self.show_status_message("System Prompt applied successfully.")
        else:
            self.current_chat_room.prompt = "You are a helpful AI assistant." # Reset to default if empty
            self.show_status_message("System Prompt reset to default.", is_error=True)

    def store_user_input(self):
        if not self.current_chat_room: return

        input = self.ui.input_text.toPlainText().strip()
        if self.current_chat_room.input_txt == input:
            return
        elif input:
            self.current_chat_room.input_txt = input
        else:
            self.current_chat_room.input_txt = ""
        
    def apply_temperature(self):
        if not self.current_chat_room: return

        self.current_chat_room.temperature = self.ui.temp_combo.currentText()
        self.show_status_message("Temperature applied successfully.")

    def default_llm(self, msg):
        if not self.current_chat_room or not self.current_chat_room.api_key:
            self.show_status_message("API Key is not set for the current chat room.", is_error=True)
            return
        if not self.current_chat_room.prompt:
            self.show_status_message("System Prompt is not set for the current chat room.", is_error=True)
            return

        response = None
        try:
            chat_model = ChatOpenAI(
                api_key=self.current_chat_room.api_key,
                temperature=float(self.current_chat_room.temperature),
            )
            prompt = ChatPromptTemplate.from_messages(
                [
                    ("system", self.current_chat_room.prompt),
                    ("human", "{input}"),
                ]
            )
            chain = prompt | chat_model

            response = chain.invoke(
                {"input": msg},
            )
        except Exception as e:
            self.show_status_message(f"Error sending message (Default LLM): {e}", is_error=True)

        if response:
            self.current_chat_room.append_non_history_log("Ai Messages: ")
            words = response.content.split(' ')
            
            # Stream effect
            for i, w in enumerate(words):
                self.current_chat_room.non_history_log += w
                if i < len(words) - 1:
                    self.current_chat_room.non_history_log += " "
                self.ui.non_history_txt.setText(self.current_chat_room.non_history_log)
                QCoreApplication.processEvents()
                time.sleep(0.05)
            self.current_chat_room.non_history_log += "\n" # Newline after full response
            self.ui.non_history_txt.setText(self.current_chat_room.non_history_log) # Final update
            self.current_chat_room.append_non_history_log("") # Add empty line for spacing
        
        self.ui.non_history_txt.verticalScrollBar().setValue(self.ui.non_history_txt.verticalScrollBar().maximum())


    def history_llm(self, msg):
        if not self.current_chat_room or not self.current_chat_room.api_key:
            self.show_status_message("API Key is not set for the current chat room.", is_error=True)
            return
        if not self.current_chat_room.prompt:
            self.show_status_message("System Prompt is not set for the current chat room.", is_error=True)
            return

        response = None
        try:
            chat_model = ChatOpenAI(
                api_key=self.current_chat_room.api_key,
                temperature=float(self.current_chat_room.temperature),
            )
            prompt = ChatPromptTemplate.from_messages(
                [
                    ("system", self.current_chat_room.prompt),
                    ("placeholder", "{chat_history}"),
                    ("human", "{input}"),
                ]
            )
            chain = prompt | chat_model

            # Increment session_id_counter for a unique session_id for each interaction
            # This is a simplification; in a real app, session_id might be tied to the chat room.
            # For LangChain's RunnableWithMessageHistory, 'session_id' can be anything if you're using a single ChatMessageHistory instance per chat room.
            self.session_id_counter += 1
            session_id = f"chat_room_{id(self.current_chat_room)}_{self.session_id_counter}"

            chain_history = RunnableWithMessageHistory(
                chain,
                lambda sid: self.current_chat_room.chat_history, # Pass the specific chat room's history
                input_messages_key="input",
                history_messages_key="chat_history",
            )

            response = chain_history.invoke(
                {"input": msg},
                {"configurable": {"session_id": session_id}},
            )
        except Exception as e:
            self.show_status_message(f"Error sending message (History LLM): {e}", is_error=True)
        
        if response:
            self.current_chat_room.append_history_log("Ai Messages: ")
            words = response.content.split(' ')
            
            # Stream effect
            for i, w in enumerate(words):
                self.current_chat_room.history_log += w
                if i < len(words) - 1:
                    self.current_chat_room.history_log += " "
                self.ui.history_txt.setText(self.current_chat_room.history_log)
                QCoreApplication.processEvents()
                time.sleep(0.05)
            self.current_chat_room.history_log += "\n" # Newline after full response
            self.ui.history_txt.setText(self.current_chat_room.history_log) # Final update
            self.current_chat_room.append_history_log("") # Add empty line for spacing
        
        self.ui.history_txt.verticalScrollBar().setValue(self.ui.history_txt.verticalScrollBar().maximum())


if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = Window()
    win.show()
    sys.exit(app.exec_())
